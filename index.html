<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Fui Yong Hakka — Study</title>
  <style>
    /* =========================
   THEME TOKENS
   ========================= */
:root{
  --bg:#0f1115; --ink:#e5e7eb; --muted:#94a3b8;
  --card:#161a22; --line:#263042;

  /* Hakka tone colors */
  --tone1:#ef4444; --tone2:#3b82f6; --tone3:#22c55e;
  --tone4:#a855f7; --tone5:#fb923c; --tone6:#eab308;
}

/* Light scheme overrides (keeps the original vibe) */
body.light{
  --bg:#fafafa; --ink:#0f1115; --muted:#475569;
  --card:#ffffff; --line:#cbd5e1;
}

/* =========================
   BASE LAYOUT & TYPE
   ========================= */
body{
  margin:0; background:var(--bg); color:var(--ink);
  font-family:Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
}
.container{ max-width:1080px; margin:0 auto; padding:24px; }
header{ display:flex; align-items:center; justify-content:space-between; gap:12px; margin-bottom:14px; }
h1{ margin:0; font-size:36px; font-weight:800; letter-spacing:.4px; }
.subtitle{ color:var(--muted); }

/* =========================
   UTILITIES
   ========================= */
.row{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
.small{ font-size:14px; color:var(--muted); }
.mono{ font-family:ui-monospace, SFMono-Regular, Menlo, monospace; font-size:12px; }

/* Inputs */
input[type="text"], textarea, select{
  background:#0b0f18; color:var(--ink); border:1px solid var(--line);
  border-radius:10px; padding:10px;
}
body.light input[type="text"], body.light textarea, body.light select{ background:#fff; }

/* =========================
   COMPONENTS
   ========================= */
.card{
  background:var(--card); border:1px solid var(--line); border-radius:14px;
  padding:16px; box-shadow:0 10px 30px rgba(0,0,0,.25);
}
.pill{
  padding:6px 10px; border-radius:999px; background:#0b0f18;
  border:1px solid var(--line); color:var(--muted); font-size:24px;
}
body.light .pill{ background:#eef2f7; }

.btn{
  background:#141a27; border:1px solid var(--line); color:var(--ink);
  border-radius:12px; padding:10px 12px; cursor:pointer;
}
body.light .btn{ background:#f8fafc; }
.btn.good{ border-color:#16a34a; }
.btn.warn{ border-color:#f59e0b; }
.btn.bad { border-color:#ef4444; }

.tabbar{ display:flex; gap:8px; margin-bottom:10px; flex-wrap:wrap; }
.tabbar button{
  background:#141a27; color:var(--ink); border:1px solid var(--line);
  border-radius:10px; padding:10px 12px; cursor:pointer;
}
.tabbar button[aria-selected="true"]{ background:#1a2340; }
body.light .tabbar button{ background:#f3f4f6; }
body.light .tabbar button[aria-selected="true"]{ background:#dbeafe; }

.tabpanel{ display:none; }
.tabpanel[aria-hidden="false"]{ display:block; }

/* =========================
   TYPOGRAPHY (Card faces)
   ========================= */
.big{ font-size:40px; text-align:center; line-height:1.2; }
.char{ font-size:56px; font-weight:800; line-height:1.05; margin-bottom:6px; }
.label{ font-size:32px; font-weight:800; margin:10px 0 2px; }
.pron{ font-size:40px; margin:6px 0 8px; }

/* =========================
   PANEL LAYOUT HELPERS
   (Bottom-centered Next buttons)
   ========================= */
#panel-mc, #panel-flash, #panel-typing{
  position:relative; min-height:360px; padding-bottom:72px;
}
#mc-next, #flash-next, #typing-next{
  position:absolute; left:50%; transform:translateX(-50%); bottom:12px;
}

/* =========================
   TABLES (Review & Stats/Vocab)
   ========================= */
#panel-stats table, #rev-list table{
  width:100%; border-collapse:collapse;
  /* Note: font size differs by section—override below */
}
#panel-stats table{ font-size:24px; }
#rev-list table   { font-size:24px; }

#panel-stats thead th, #rev-list thead th{
  text-align:left; padding:8px 10px; border-bottom:1px solid var(--line); font-weight:700;
}
#panel-stats tbody td, #rev-list tbody td{
  padding:8px 10px; border-bottom:1px solid var(--line); vertical-align:top;
}
#panel-stats tbody tr:last-child td, #rev-list tbody tr:last-child td{ border-bottom:none; }

/* Review/Vocab specific cells */
#rev-list .rev-pron .play{ margin-left:8px; }
#rev-list .rev-acc{ width:120px; text-align:right; white-space:nowrap; }
#rev-list .rev-due{ width:120px; text-align:right; white-space:nowrap; color:var(--muted); }

/* =========================
   FEEDBACK TAG (MC/Typing)
   ========================= */
.result-tag{
  display:inline-block; padding:4px 10px; border-radius:999px;
  font-size:24px; font-weight:600; margin-bottom:10px; border:1px solid var(--line);
}
.result-tag.correct  { color:#16a34a; border-color:#16a34a22; background:rgba(22,163,74,.08); }
.result-tag.incorrect{ color:#ef4444; border-color:#ef444422; background:rgba(239,68,68,.08); }

  </style>
  
</head>
<body>
  <div class="container">
    <header>
      <div>
        <h1>Hong Kong Fui Yong Hakka — Study</h1>
        <div class="subtitle"> • Flashcards / Multiple Choice / Typing</div>
      </div>
      <div class="row">
        <div class="pill" id="streak-session">Session: 0</div>
        <div class="pill" id="streak-life">Lifetime: 0</div>
        <button id="theme-toggle" class="btn" title="Toggle dark mode">Dark Mode</button>
      </div>
    </header>

    <div class="card">
      <div class="tabbar" role="tablist" aria-label="Modes">
        <button role="tab" id="tab-flash" aria-selected="true" data-panel="flash">Flashcards</button>
        <button role="tab" id="tab-mc" data-panel="mc">Multiple Choice</button>
        <button role="tab" id="tab-typing" data-panel="typing">Typing</button>
        <button role="tab" id="tab-review" data-panel="review">Reviewing</button>
        <button role="tab" id="tab-stats" data-panel="stats">Vocabulary</button> <!-- was "Stats" but can't be bothered to rename it everywhere else... -->
        <button role="tab" id="tab-manage" data-panel="manage">Import/Export</button>
      </div>

      <!-- FLASHCARDS -->
      <section class="tabpanel" id="panel-flash" aria-hidden="false" aria-labelledby="tab-flash">
        <div class="big" id="flash-front"></div>
        <div class="big" id="flash-back" style="display:none;margin-top:10px;opacity:.98"></div>
        <div class="row" style="justify-content:center;margin-top:14px">
          <button id="btn-show" class="btn">Show</button>
          <button id="btn-again" class="btn bad" style="display:none">Again</button>
          <button id="btn-hard" class="btn warn" style="display:none">Hard</button>
          <button id="btn-good" class="btn" style="display:none">Good</button>
          <button id="btn-easy" class="btn good" style="display:none">Easy</button>
          <button id="flash-next" class="btn" style="display:none;margin-top:10px">Next</button>
        </div>
        <div class="small" style="text-align:center;margin-top:8px"><span id="queue-info">0 due</span></div>
      </section>

      <!-- MULTIPLE CHOICE -->
      <section class="tabpanel" id="panel-mc" aria-hidden="true" aria-labelledby="tab-mc">
        <div id="mc-question" class="big"></div>
        <div id="mc-options" class="row" style="margin-top:16px;justify-content:center;flex-wrap:wrap"></div>
        <div id="mc-feedback" class="small" style="margin-top:8px;text-align:center"></div>
        <button id="mc-next" class="btn" style="display:none;margin-top:10px">Next</button>
      </section>

      <!-- TYPING -->
      <section class="tabpanel" id="panel-typing" aria-hidden="true" aria-labelledby="tab-typing">
        <div class="row" style="justify-content:center;gap:8px;margin-bottom:8px">
          <label for="typing-mode" class="small">Answer in:</label>
          <select id="typing-mode">
            <option value="eng" selected>English</option>
            <option value="mandarin">Mandarin (普通中文)</option>
            <option value="pron">Hakka pronunciation</option>
          </select>
        </div>
        <div id="typing-question" class="big"></div>
        <div class="row" style="margin-top:12px;justify-content:center">
          <input id="typing-input" type="text" placeholder="Type the English and press Enter" style="min-width:340px" />
        </div>
        <div id="typing-feedback" class="small" style="margin-top:6px;text-align:center"></div>
        <button id="typing-next" class="btn" style="display:none;margin-top:10px">Next</button>
      </section>


      <!-- REVIEWING (like Flashcards but always shows back) -->
       <section class="tabpanel" id="panel-review" aria-hidden="true" aria-labelledby="tab-review">
          <div class="row" style="gap:12px;align-items:center;flex-wrap:wrap;margin-bottom:8px">
            <div class="pill">Learned: <span id="rev-learned-count">0</span></div>
            <div class="pill">Mistakes: <span id="rev-mistake-count">0</span></div>
            <div class="pill">Due Today: <span id="rev-due-count">0</span></div>

            <label class="small" style="margin-left:8px">Show:</label>
            <select id="rev-filter">
              <option value="learned" selected>Learned</option>
              <option value="mistakes">Mistakes</option>
              <option value="due">Due Today</option>
             
            </select>
          </div>

          <div id="rev-list" class="card" style="padding:12px"></div>
        </section>

      <!-- STATS + embedded Vocabulary table + search -->
      <section class="tabpanel" id="panel-stats" aria-hidden="true" aria-labelledby="tab-stats">
        <div class="row" style="gap:24px;flex-wrap:wrap">
          <div class="pill">Due: <span id="stat-due">0</span></div>
          <div class="pill">New: <span id="stat-new">0</span></div>
          <div class="pill">Review: <span id="stat-review">0</span></div>
          <div class="pill">Total: <span id="stat-total">0</span></div>
        </div>
        <div class="row" style="gap:12px;flex-wrap:wrap;margin-top:12px">
          <div class="pill stat-pill">Session Vocab: <span id="vocab-session">0</span></div>
          <div class="pill stat-pill">Lifetime Vocab: <span id="vocab-life">0</span></div>
        </div>
        <!-- Search row for vocabulary -->
        <div class="row" style="gap:12px;flex-wrap:wrap;margin:16px 0 8px">
          <input id="vocab-search" type="text" placeholder="Search English / Hakka pronunciation / 普通中文 / 客家汉字" style="flex:1;min-width:260px" />
        </div>

        <!-- Vocabulary table lives here -->
        <div id="vocab-list" class="card" style="padding:12px"></div>
      </section>

      <!-- IMPORT/EXPORT -->
      <section class="tabpanel" id="panel-manage" aria-hidden="true" aria-labelledby="tab-manage">
        <div class="row" style="gap:12px;align-items:flex-start;flex-wrap:wrap">
          <div style="flex:1 1 360px" class="card">
            <h3>Import CSV</h3>
            <div class="small">CSV header must be <span class="mono">普通中文,客家汉字,Hakka Pronunciation,English Definition</span></div>
            <textarea id="csv-text" rows="6" placeholder="普通中文,客家汉字,Hakka Pronunciation,English Definition&#10;昨天,晡晡日,cam2 min2 ngit5,Yesterday" style="width:100%"></textarea>
            <div class="row" style="margin-top:10px">
              <input id="csv-file" type="file" accept=".csv" />
              <button id="import-csv" class="btn">Import</button>
            </div>
          </div>
          <div style="flex:1 1 300px" class="card">
            <h3>Backup / Restore</h3>
            <div class="row">
              <button id="export-json" class="btn">Export Progress</button>
              <input id="import-json-file" type="file" accept="application/json" />
              <button id="import-json" class="btn">Import Progress</button>
            </div>
            <div class="small">Progress is saved in your browser (localStorage).</div>
          </div>
        </div>
      </section>
    </div>

    <footer class="small" style="margin-top:14px;opacity:.8">Stores your "progress" in your browser. Nothing is stored online.</footer>
  </div>

  <script>
  // ===== Theme toggle (using body.light, preserving original look) =====
  (function(){
    const btn=document.getElementById('theme-toggle');
    const saved=localStorage.getItem('theme');
    if(saved==='light') document.body.classList.add('light');
    btn.textContent=document.body.classList.contains('light')? 'Dark Mode':'Light Mode';
    btn.onclick=()=>{
      document.body.classList.toggle('light');
      const isLight=document.body.classList.contains('light');
      localStorage.setItem('theme', isLight? 'light':'dark');
      btn.textContent=isLight? 'Dark Mode':'Light Mode';
    };
  })();

  // ===== SRS scheduling =====
  const DAY=24*60*60*1000; const now=()=>Date.now();
  function schedule(card, rating){
    const q = {Again:0, Hard:1, Good:2, Easy:3}[rating] ?? 2;
    if(card.reps==null) card.reps=0; if(card.ease==null) card.ease=2.5; if(card.interval==null) card.interval=0;
    if(q===0){ card.interval=0.5; card.ease=Math.max(1.3, card.ease-0.2); card.reps=0; }
    else {
      if(card.reps===0){ card.interval=q===3?4/24:q===2?1:0.5; }
      else if(card.reps===1){ card.interval=q===3?3:q===2?2:1; }
      else { card.ease=Math.max(1.3, card.ease+(q-1)*0.05-0.02); card.interval=Math.round(card.interval*card.ease*(q===1?0.9:q===3?1.15:1.0)); }
      card.reps+=1;
    }
    card.due = now() + card.interval*DAY;
  }

  // ===== Record per-card study stats =====
  function updateCardStats(card, ok){
    if(card.firstSeenAt==null) card.firstSeenAt = now();
    card.lastSeenAt = now();
    card.seenCount  = (card.seenCount||0) + 1;
    if(ok===true)  card.correctCount   = (card.correctCount||0) + 1;
    if(ok===false) card.incorrectCount = (card.incorrectCount||0) + 1;
    card.studied = true;
  }

  // ===== Storage =====
  const STORE_KEY='srs_decks_v1';
  const loadAll=()=>{try{return JSON.parse(localStorage.getItem(STORE_KEY))||{}}catch(e){return {}}};
  const saveAll=d=>localStorage.setItem(STORE_KEY, JSON.stringify(d));
  let decks=loadAll(); let currentDeck=null; let reviewQueue=[]; let currentIndex=null;
  const $=id=>document.getElementById(id);

  // ===== Streak (session vs lifetime) =====
  function getLife(){ return parseInt(localStorage.getItem('streak_life')||'0',10)||0; }
  function setLife(n){ localStorage.setItem('streak_life', String(n)); const el=$('streak-life'); if(el) el.textContent='Lifetime: '+n; }
  function getSession(){ const el=$('streak-session'); const m=(el&&el.textContent||'').match(/(\d+)/); return m?parseInt(m[1],10):0; }
  function setSession(n){ const el=$('streak-session'); if(el) el.textContent='Session: '+n; }
  function bumpStreak(){ setSession(getSession()+1); setLife(getLife()+1);syncVocabCounters();  }

  // ===== Vocab (session vs lifetime) — mirror the streak pills =====
  function syncVocabCounters(){
    const s = getSession();
    const l = getLife();
    const sv = document.getElementById('vocab-session');
    const lv = document.getElementById('vocab-life');
    if(sv) sv.textContent = s;
    if(lv) lv.textContent = l;
  }

  // keep the old names but make them wrappers so existing calls don't break
  function getLifeVocab(){ return getLife(); }
  function setLifeVocab(n){ setLife(n); syncVocabCounters(); }
  function getSessionVocab(){ return getSession(); }
  function setSessionVocab(n){ setSession(n); syncVocabCounters(); }
  function bumpVocab(){ syncVocabCounters(); }

  // ===== Tone coloring & diacritics =====
  const TONE_COLORS={'1':'var(--tone1)','2':'var(--tone2)','3':'var(--tone3)','4':'var(--tone4)','5':'var(--tone5)','6':'var(--tone6)'};
  const TONE_DIACRITICS={'1':'́','2':'̄','3':'̌','4':'̀','5':'̌','6':'̀'};
  const toneSpan=(t,n)=>`<span style="color:${TONE_COLORS[n]||'#fff'}">${t}</span>`;
  const extractTones=pron=>(pron.match(/[1-6]/g)||[]);
  function colorizeCharacters(chars, pron){const tones=extractTones(pron); const out=[]; for(let i=0;i<chars.length;i++){out.push(toneSpan(chars[i], tones[i%tones.length]||'2'));} return out.join('');}
  function convertToneNumbersToDiacritics(pron){return pron.replace(/([A-Za-z]+)([1-6])/g,(m,syl,t)=>{const mark=TONE_DIACRITICS[t]||'';const vs=[...syl].map((c,i)=>'aeiouAEIOU'.includes(c)?i:-1).filter(i=>i>=0);let idx=vs.length>=2?vs[vs.length-2]:(vs[0]??-1);if(idx>=0){syl=syl.slice(0,idx+1)+mark+syl.slice(idx+1);}return toneSpan(syl,t);});}

  // ===== TTS (https://hkilang.github.io/TTS/) =====
  const TTS_API_URL = "https://Chaak2.pythonanywhere.com/TTS/hakka";
  function playTTS(pron){
    const url = `${TTS_API_URL}/${encodeURIComponent((pron||'').trim())}?voice=male&speed=0.5`;
    new Audio(url).play().catch(()=>{});
  }

  // ===== Render helpers (used in all 3 modes) =====
  function frontHTML(row){
    return `<div class="char">${colorizeCharacters(row.hakka_chars,row.pronunciation)}</div>
            <div class="label">Hakka Pronunciation:</div>
            <div class="pron">${convertToneNumbersToDiacritics(row.pronunciation)}</div>`;
  }
  function backHTML(row){
    const playBtn = `<button id="play-tts" class="btn" style="border-radius:999px;width:56px;height:56px;display:inline-flex;align-items:center;justify-content:center">▶</button>`;
    return `<div class="char">${colorizeCharacters(row.hakka_chars,row.pronunciation)}</div>
            <div class="label">Hakka Pronunciation:</div>
            <div class="pron">${convertToneNumbersToDiacritics(row.pronunciation)}</div>
            <div style="font-size:24px;margin:6px 0"><strong>普通中文:</strong> ${row.mandarin||''}</div>
            <div style="font-size:24px;margin:6px 0"><strong>Eng:</strong> ${row.english||''}</div>
            <div style="text-align:center;margin-top:6px">${playBtn}</div>`;
  }

  // ===== CSV parsing =====
  function parseCSV(text){const rows=[]; let cur=''; let inQ=false; let cols=[]; const push=()=>{cols.push(cur); cur='';}; for(let i=0;i<text.length;i++){const ch=text[i]; if(ch==='\r') continue; if(ch==='\n'){ if(inQ){cur+='\n';} else {push(); rows.push(cols); cols=[];} continue;} if(ch==='"'){inQ=!inQ; continue;} if(ch===','&&!inQ){push(); continue;} cur+=ch;} if(cur.length||cols.length){push(); rows.push(cols);} return rows;}

  // ===== Deck bootstrap: CSV only =====
  function rowsToCards(rows){ return rows.map(row=>({ id: uid(), front: `${row.hakka_chars} || ${row.pronunciation}`, back: JSON.stringify(row) })); }
  async function loadSeedFromCSV(){
    try{
      const res = await fetch('Hakka%20Vocabulary.csv');
      if(!res.ok) return null; const txt = await res.text();
      const rows = parseCSV(txt); if(!rows.length) return null;
      const header = rows[0];
      const idx = {
        mandarin: header.indexOf('普通中文'),
        hakka_chars: header.indexOf('客家汉字'),
        pronunciation: header.indexOf('Hakka Pronunciation'),
        english: header.indexOf('English Definition')
      };
      const data = rows.slice(1).map(r=>({
        mandarin: r[idx.mandarin]||'',
        hakka_chars: r[idx.hakka_chars]||'',
        pronunciation: r[idx.pronunciation]||'',
        english: r[idx.english]||''
      })).filter(x=>x.hakka_chars && x.pronunciation);
      return data;
    }catch(e){ return null; }
  }

  function loadAllCards(){
    const names=Object.keys(decks);
    if(names.length){ currentDeck = decks[names[0]]; return; }
    currentDeck=null;
  }

  // ===== Randomized "due" queue (still ends cleanly) =====
  function shuffle(a){ return a.slice().sort(()=>Math.random()-0.5); }
  function buildQueue(){
    if(!currentDeck){ reviewQueue=[]; currentIndex=null; $('queue-info').textContent='0 due'; summarizeStats(); return; }
    const nowt=now();
    const dueIdx = currentDeck.cards.map((c,i)=>({i,due:c.due||0,reps:c.reps||0}))
      .filter(x=>x.due<=nowt)
      .map(x=>x.i);
    reviewQueue = shuffle(dueIdx);                  // randomized order
    currentIndex = reviewQueue.length? 0 : null;    // ends as "All done!" when empty
    $('queue-info').textContent = `${reviewQueue.length} due`;
    summarizeStats();
  }

  function summarizeStats(){
  if(!currentDeck){
    $('stat-due').textContent='0'; $('stat-new').textContent='0';
    $('stat-review').textContent='0'; $('stat-total').textContent='0';
    if($('vocab-session')) $('vocab-session').textContent = getSessionVocab();
    if($('vocab-life')) $('vocab-life').textContent = getLifeVocab();
    return;
  }
  const cs=currentDeck.cards; const total=cs.length; const nowt=now();
  const due=cs.filter(c=>!c.due||c.due<=nowt).length;
  const newc=cs.filter(c=>!c.reps).length;
  const review=Math.max(0, due-newc);
  $('stat-due').textContent=due; $('stat-new').textContent=newc;
  $('stat-review').textContent=review; $('stat-total').textContent=total;

  // Keep vocab counters in sync when visiting Stats
  if($('vocab-session')) $('vocab-session').textContent = getSessionVocab();
  if($('vocab-life')) $('vocab-life').textContent = getLifeVocab();
}

function timeUntil(ts){
  if(!ts) return '—';
  const d = ts - now();
  if(d <= 0) return 'due now';
  const mins = Math.round(d/60000);
  if(mins < 60) return `in ${mins}m`;
  const hrs = Math.round(mins/60);
  if(hrs < 48) return `in ${hrs}h`;
  const days = Math.round(hrs/24);
  return `in ${days}d`;
}

function renderReview(){
  if(!currentDeck){
    $('rev-list').innerHTML = '<div class="small">No deck</div>';
    $('rev-due-count').textContent='0';
    $('rev-learned-count').textContent='0';
    $('rev-mistake-count').textContent='0';
    return;
  }
  const cs = currentDeck.cards;
  const nowt = now();

  const due      = cs.filter(c=>(c.reps||0)>0 && (c.due||0)<=nowt);
  const learned  = cs.filter(c=>(c.reps||0)>0);
  const mistakes = cs.filter(c=>(c.incorrectCount||0)>0);

  $('rev-due-count').textContent      = due.length;
  $('rev-learned-count').textContent  = learned.length;
  $('rev-mistake-count').textContent  = mistakes.length;

  const filter = $('rev-filter').value;
  let list = filter==='due' ? due : (filter==='learned' ? learned : mistakes);

  // sort: due soonest first; otherwise by lastSeen desc
  list = list.slice().sort((a,b)=>{
    const ad = a.due||0, bd = b.due||0;
    if(filter==='due') return ad - bd;
    return (b.lastSeenAt||0) - (a.lastSeenAt||0);
  });

  if(list.length===0){
    $('rev-list').innerHTML = '<div class="small">Nothing here yet.</div>';
    return;
  }

  // Build 6-column table
  let html = `
    <table>
      <thead>
        <tr>
          <th>普通中文</th>
          <th>客家汉字</th>
          <th>Hakka Pronunciation</th>
          <th>English Definition</th>
          <th class="rev-acc">✓ / ✗</th>
          <th class="rev-due">Due in</th>
        </tr>
      </thead>
      <tbody>
  `;

  html += list.map(card=>{
    let row; try{ row = JSON.parse(card.back); } catch { row = null; }
    if(!row) return '';
    const charHTML = `<div class="rev-hakka">${colorizeCharacters(row.hakka_chars,row.pronunciation)}</div>`;
    const pronHTML = `
      <div class="rev-pron">
        ${convertToneNumbersToDiacritics(row.pronunciation)}
        <button class="btn play" data-pron="${encodeURIComponent(row.pronunciation)}" title="Play audio">▶</button>
      </div>`;

    return `
      <tr>
        <td>${row.mandarin || ''}</td>
        <td>${charHTML}</td>
        <td>${pronHTML}</td>
        <td>${row.english || ''}</td>
        <td class="rev-acc">${(card.correctCount||0)}&nbsp;✓&nbsp;/&nbsp;${(card.incorrectCount||0)}&nbsp;✗</td>
        <td class="rev-due">${timeUntil(card.due)}</td>
      </tr>
    `;
  }).join('');

  html += `</tbody></table>`;
  $('rev-list').innerHTML = html;

  // Delegate click for TTS
  $('rev-list').onclick = (e)=>{
    const btn = e.target.closest('button.play');
    if(!btn) return;
    const raw = decodeURIComponent(btn.getAttribute('data-pron')||'');
    if(raw) playTTS(raw);
  };
}

function renderVocabInStats(){
  const box = document.getElementById('vocab-list');
  if(!box){ return; }

  if(!currentDeck || !Array.isArray(currentDeck.cards) || currentDeck.cards.length===0){
    box.innerHTML = '<div class="small">No deck</div>';
    return;
  }

  // Start from cards (same as Reviewing), then JSON.parse each back
  let list = currentDeck.cards.slice();

  // Search: English, Hakka pronunciation, 普通中文, 客家汉字
  const q = (document.getElementById('vocab-search')?.value || '').trim().toLowerCase();
  if(q){
    list = list.filter(card=>{
      let row; try { row = JSON.parse(card.back); } catch { row = null; }
      if(!row) return false;
      const hay = `${row.mandarin||''} ${row.hakka_chars||''} ${row.pronunciation||''} ${row.english||''}`.toLowerCase();
      return hay.includes(q);
    });
  }

  if(list.length===0){
    box.innerHTML = '<div class="small">No matches</div>';
    return;
  }

  // Build table (CSV-style) — same 4 columns
  let html = `
    <table>
      <thead>
        <tr>
          <th>普通中文</th>
          <th>客家汉字</th>
          <th>Hakka Pronunciation</th>
          <th>English Definition</th>
        </tr>
      </thead>
      <tbody>
  `;

  html += list.map(card=>{
    let row; try{ row = JSON.parse(card.back); } catch { row = null; }
    if(!row) return '';

    const charHTML = `<div class="rev-hakka">${colorizeCharacters(row.hakka_chars, row.pronunciation)}</div>`;
    const pronHTML = `
      <div class="rev-pron">
        ${convertToneNumbersToDiacritics(row.pronunciation)}
        <button class="btn play" data-pron="${encodeURIComponent(row.pronunciation || '')}" title="Play audio">▶</button>
      </div>`;

    return `
      <tr>
        <td>${row.mandarin || ''}</td>
        <td>${charHTML}</td>
        <td>${pronHTML}</td>
        <td>${row.english || ''}</td>
      </tr>
    `;
  }).join('');

  html += `</tbody></table>`;
  box.innerHTML = html;
}

// Re-render when searching
document.getElementById('vocab-search')?.addEventListener('input', renderVocabInStats);

document.getElementById('vocab-list')?.addEventListener('click', (e)=>{
  const btn = e.target.closest('button.play');
  if(!btn) return;
  const raw = decodeURIComponent(btn.getAttribute('data-pron') || '');
  if(raw) playTTS(raw);
});

// Also render whenever the Stats tab is shown (and keep your existing summarizeStats call)
document.getElementById('tab-stats')?.addEventListener('click', ()=>{
  summarizeStats();
  renderVocabInStats();
});

// when filter changes, re-render
$('rev-filter').addEventListener('change', renderReview);

// when the Reviewing tab is opened
document.getElementById('tab-review')?.addEventListener('click', renderReview);

// ===== Flashcards (Anki-style ratings + SRS + autoplay TTS) =====
function showFlash(){
  const btnShow = $('btn-show');
  const btnNext = $('flash-next'); // we’ll keep it hidden; ratings handle advance
  const rateIds = ['btn-again','btn-hard','btn-good','btn-easy'];

  if(currentIndex==null || !currentDeck || !currentDeck.cards?.length){
    $('flash-front').textContent='All done!';
    $('flash-back').style.display='none';
    btnShow.style.display='inline-block';
    btnNext.style.display='none';
    rateIds.forEach(id=>$(id).style.display='none');
    return;
  }

  const card = currentDeck.cards[reviewQueue[currentIndex]];
  let row; try{ row = JSON.parse(card.back); } catch { row = null; }

  // FRONT (Hakka chars + pron only, with tone colors)
  $('flash-front').innerHTML = row ? frontHTML(row) : (card.front || '');
  $('flash-back').style.display='none';

  // Only Show visible initially
  btnShow.style.display='inline-block';
  btnNext.style.display='none';
  rateIds.forEach(id=>$(id).style.display='none');
}

function revealFlash(){
  if(currentIndex==null) return;
  const btnShow = $('btn-show');
  const btnNext = $('flash-next'); // not used; stays hidden
  const rateIds = ['btn-again','btn-hard','btn-good','btn-easy'];

  const card = currentDeck.cards[reviewQueue[currentIndex]];
  let row; try{ row = JSON.parse(card.back); } catch { row = null; }

  // Replace FRONT with BACK (like MC) and wire/play TTS
  if(row){
    $('flash-front').innerHTML = backHTML(row);
    const pb = $('play-tts'); 
    if(pb){ pb.onclick = () => playTTS(row.pronunciation); }
    playTTS(row.pronunciation);   // autoplay after Show click
  } else {
    $('flash-front').textContent = card.back || '(no back)';
  }

  $('flash-back').style.display='none';
  btnShow.style.display='none';
  btnNext.style.display='none';
  rateIds.forEach(id=>$(id).style.display='inline-block');
}

// Advance the queue after rating + reschedule
function rateFlash(rating){
  if(currentIndex==null) return;

  const idx   = reviewQueue[currentIndex];
  const card  = currentDeck.cards[idx];

  // SRS math
  schedule(card, rating);

  // Book-keeping for Reviewing tab:
  // Treat Again as incorrect, Hard/Good/Easy as correct.
  updateCardStats(card, rating==='Again' ? false : true);

  // Streak bumps only on a “pass” (your previous convention)
  if(rating!=='Again') bumpStreak();

  // Remove from today’s queue and advance
  reviewQueue.splice(currentIndex, 1);
  currentIndex = reviewQueue.length ? Math.min(currentIndex, reviewQueue.length-1) : null;

  // Persist + rebuild derived stats/queue labels
  saveAll(decks);
  buildQueue();
  summarizeStats();

  // Show next
  showFlash();
}

// ===== Wire Flash buttons =====
$('btn-show').onclick  = revealFlash;
$('btn-again').onclick = ()=>rateFlash('Again');
$('btn-hard').onclick  = ()=>rateFlash('Hard');
$('btn-good').onclick  = ()=>rateFlash('Good');
$('btn-easy').onclick  = ()=>rateFlash('Easy');

// Optional: keyboard shortcuts like Anki (1–4)
document.addEventListener('keydown', (e)=>{
  const panelVisible = document.getElementById('panel-flash')?.getAttribute('aria-hidden')==='false';
  if(!panelVisible || currentIndex==null) return;
  if(e.key===' ' || e.key==='Enter'){ // Space/Enter to Show when hidden
    const showVisible = $('btn-show').style.display !== 'none';
    if(showVisible){ e.preventDefault(); revealFlash(); }
    return;
  }
  // 1..4 map to Again/Hard/Good/Easy if rating buttons visible
  const ratedVisible = $('btn-again').style.display !== 'none';
  if(!ratedVisible) return;
  if(e.key==='1'){ e.preventDefault(); rateFlash('Again'); }
  if(e.key==='2'){ e.preventDefault(); rateFlash('Hard');  }
  if(e.key==='3'){ e.preventDefault(); rateFlash('Good');  }
  if(e.key==='4'){ e.preventDefault(); rateFlash('Easy');  }
});

  // ===== Multiple Choice (hold after reveal, Next to advance, TTS autoplay) =====

    function nextMC(){
    if(!currentDeck || !currentDeck.cards.length){
        $('mc-question').textContent='No deck';
        $('mc-options').innerHTML='';
        $('mc-feedback').innerHTML='';
        $('mc-next').style.display='none';
        return;
    }

    // Choose a due card (or random if none due)
    const dueIdx  = (reviewQueue.length ? (currentIndex ?? 0) : Math.floor(Math.random()*currentDeck.cards.length));
    const cardIdx = reviewQueue.length ? reviewQueue[dueIdx] : dueIdx;
    const correct = currentDeck.cards[cardIdx];

    let row; try{ row = JSON.parse(correct.back); } catch { row = null; }

    // FRONT as the prompt
    $('mc-question').innerHTML = row ? frontHTML(row) : correct.front;

    // Build option buttons
    const pool = currentDeck.cards.filter(c => c !== correct);
    const distractors = shuffle(pool).slice(0,3);
    const options = shuffle([correct, ...distractors]);

    const box = $('mc-options'); box.innerHTML='';
    $('mc-feedback').innerHTML='';
    const btnNext = $('mc-next'); btnNext.style.display='none';
    box.style.display = 'flex';
    let locked = false;

    function lockButtons(){
        locked = true;
        [...box.querySelectorAll('button')].forEach(b => b.disabled = true);
    }

    options.forEach(opt=>{
        let oRow; try{ oRow = JSON.parse(opt.back); } catch { oRow = null; }
        const label = oRow ? (oRow.english || oRow.mandarin || opt.back) : opt.back;

        const b = document.createElement('button');
        b.className = 'btn';
        b.textContent = label;
        b.onclick = () => {
        if(locked) return;
        const ok = (opt === correct);
        b.style.borderColor = ok ? '#16a34a' : '#ef4444';

        // Build a subtle tag + replace FRONT with BACK
        const tag = `<div class="result-tag ${ok?'correct':'incorrect'}" aria-live="polite">${ok?'Correct':'Incorrect'}</div>`;
        if(row){
            $('mc-question').innerHTML = tag + backHTML(row);
            const pb = $('play-tts'); if(pb){ pb.onclick = () => playTTS(row.pronunciation); }
            playTTS(row.pronunciation); // autoplay on reveal
        } else {
            $('mc-question').innerHTML = tag + (correct.back || '(no back)');
        }

        // Hide options after reveal (so back fully replaces the front)
        lockButtons();
        box.style.display = 'none';

        // Schedule / streak / queue — no auto-advance
        schedule(correct, ok ? 'Good' : 'Again');
        updateCardStats(correct, ok);
        if (ok) bumpStreak();
        buildQueue();

        saveAll(decks);

        btnNext.style.display = 'inline-block';
        };
        box.appendChild(b);
    });

  // Advance on Next
  btnNext.onclick = () => {
    if(reviewQueue.length){
      currentIndex = Math.min(currentIndex ?? 0, Math.max(0, reviewQueue.length - 1));
    } else {
      currentIndex = null;
    }
    nextMC();
  };
}


// ===== Typing (MC-like: result tag, back replaces front, TTS autoplay, Next) =====
let typingMode='eng';
document.getElementById('typing-mode').onchange=e=>{
  typingMode=e.target.value; localStorage.setItem('typingMode', typingMode);
  const inp=document.getElementById('typing-input');
  inp.placeholder = typingMode==='eng'
    ? 'Type English and press Enter'
    : (typingMode==='mandarin' ? '輸入普通中文...' : 'Use Hakka pinyim number tone. e.g. lui4 zui4 ');
};
(function(){
  const saved=localStorage.getItem('typingMode');
  if(saved){ typingMode=saved; document.getElementById('typing-mode').value=saved; }
})();

// Helper: do we have a deck & queue mechanism available?
function hasDeck(){
  return (typeof currentDeck!=='undefined' && currentDeck && Array.isArray(currentDeck.cards));
}

// Core: set up one question
function nextTyping(){
  const qEl = document.getElementById('typing-question');
  const inp = document.getElementById('typing-input');
  const fb  = document.getElementById('typing-feedback');
  const nxt = document.getElementById('typing-next');

  if(!hasDeck() || !currentDeck.cards.length){
    qEl.textContent = 'No deck';
    inp.value=''; fb.textContent=''; nxt.style.display='none';
    return;
  }

  // If you keep the SRS queue, prefer a due card; else pick random
  const dueIdx = (Array.isArray(reviewQueue) && reviewQueue.length
                  ? (currentIndex ?? 0)
                  : Math.floor(Math.random()*currentDeck.cards.length));
  const cardIdx = (Array.isArray(reviewQueue) && reviewQueue.length) ? reviewQueue[dueIdx] : dueIdx;
  const card    = currentDeck.cards[cardIdx];

  let row; try{ row = JSON.parse(card.back); } catch { row = null; }

  // FRONT prompt with tone colors
  qEl.innerHTML = row ? frontHTML(row) : (card.front || '');
  fb.innerHTML = '';
  nxt.style.display = 'none';
  inp.disabled = false;
  inp.value = '';
  // put cursor in the field for fast drilling
  setTimeout(()=>inp.focus(), 0);

  // expected target per mode
  const expected = row
    ? (typingMode==='eng'      ? (row.english||'')
     : typingMode==='mandarin' ? (row.mandarin||'')
     :                           (row.pronunciation||''))
    : (card.back || '');

  // Key handler: Enter → reveal back (guard IME/composition)
  inp.onkeydown = (e)=>{
    if(e.isComposing) return;            // ignore while composing IME text
    if(e.key !== 'Enter') return;
    e.preventDefault();

    const ans = inp.value.trim();
    const ok  = ans.toLowerCase() === String(expected||'').toLowerCase();

    updateCardStats(card, ok);  

    // Subtle result tag + back replaces front (like MC)
    const tag = `<div class="result-tag ${ok?'correct':'incorrect'}" aria-live="polite">${ok?'Correct':'Incorrect'}</div>`;
    if(row){
      qEl.innerHTML = tag + backHTML(row);
      const pb = document.getElementById('play-tts'); if(pb){ pb.onclick = ()=>playTTS(row.pronunciation); }
      playTTS(row.pronunciation);  // autoplay after user interaction
    }else{
      qEl.innerHTML = tag + (card.back || '(no back)');
    }

    // Lock input; show Next
    inp.disabled = true;
    nxt.style.display = 'inline-block';

    // SRS bookkeeping (no auto-advance)
    if(typeof schedule==='function') schedule(card, ok ? 'Good' : 'Again');
    if(ok && typeof bumpStreak==='function') bumpStreak();
    if(typeof buildQueue==='function') buildQueue();
    saveAll(decks);
  };

  // Next → advance & re-ask
  nxt.onclick = ()=>{
    // Maintain your currentIndex policy (only if you use SRS queue)
    if(Array.isArray(reviewQueue) && reviewQueue.length){
      currentIndex = Math.min(currentIndex ?? 0, Math.max(0, reviewQueue.length - 1));
    } else {
      currentIndex = null;
    }
    // Unlock and refresh
    inp.disabled = false;
    nextTyping();
  };
}

// ---- Initialize Typing: call on load and when Typing tab selected ----
document.addEventListener('DOMContentLoaded', ()=>{
  // If your app uses a tab system, Typing might start hidden; still safe to prep the first card
  try { nextTyping(); } catch {}
});

// If your page has a tab button with id="tab-typing", wire it to refresh Typing when shown
document.getElementById('tab-typing')?.addEventListener('click', ()=>{
  nextTyping();
});

  // ===== Helpers =====
  const uid=()=>Math.random().toString(36).slice(2)+Date.now().toString(36);

  // ===== Import/Export =====
  document.getElementById('import-csv')?.addEventListener('click', async ()=>{
    if(!currentDeck){ alert('No deck loaded.'); return; }
    let text=$('csv-text').value.trim(); if(!text && $('csv-file').files[0]) text=await $('csv-file').files[0].text(); if(!text) return alert('Paste CSV or choose a file.');
    const rows=parseCSV(text); if(!rows.length) return alert('No rows detected.');
    const header=rows[0]; const idx={ mandarin: header.indexOf('普通中文'), hakka_chars: header.indexOf('客家汉字'), pronunciation: header.indexOf('Hakka Pronunciation'), english: header.indexOf('English Definition') };
    const data=rows.slice(1).map(r=>({ mandarin:r[idx.mandarin]||'', hakka_chars:r[idx.hakka_chars]||'', pronunciation:r[idx.pronunciation]||'', english:r[idx.english]||'' })).filter(x=>x.hakka_chars&&x.pronunciation);
    const added=data.map(row=>({id:uid(), front:`${row.hakka_chars} || ${row.pronunciation}`, back:JSON.stringify(row)})); currentDeck.cards.push(...added);
    saveAll(decks); buildQueue(); summarizeStats(); alert(`Imported ${added.length} cards.`);
  });

  document.getElementById('export-json')?.addEventListener('click', ()=>{ const data=JSON.stringify(decks,null,2); const blob=new Blob([data],{type:'application/json'}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='flashcards-progress.json'; a.click(); URL.revokeObjectURL(url); });
  document.getElementById('import-json')?.addEventListener('click', ()=>{ const f=$('import-json-file').files[0]; if(!f) return alert('Choose a file.'); f.text().then(txt=>{ try{ decks=JSON.parse(txt); saveAll(decks); loadAllCards(); buildQueue(); showFlash(); summarizeStats(); alert('Imported!'); }catch(e){ alert('Invalid JSON.'); } }); });

  // ===== Tabs =====
  document.querySelectorAll('[role="tab"]').forEach(tab=>{tab.addEventListener('click',()=>{
    document.querySelectorAll('.tabpanel').forEach(p=>p.setAttribute('aria-hidden','true'));
    document.getElementById('panel-'+tab.dataset.panel).setAttribute('aria-hidden','false');
    document.querySelectorAll('[role="tab"]').forEach(t=>t.setAttribute('aria-selected','false'));
    tab.setAttribute('aria-selected','true');
    if(tab.dataset.panel==='mc') nextMC();
    if(tab.dataset.panel==='typing') nextTyping();
    if(tab.dataset.panel==='flash') showFlash();
    if(tab.dataset.panel==='stats') summarizeStats();
    if(tab.dataset.panel==='review') renderReview(); 
  });});

  // ===== Bootstrap: load default CSV into a deck on first run =====
  (async function(){
    if(Object.keys(decks).length===0){
      const seed = await loadSeedFromCSV();
      if(seed && seed.length){ const name='Hakka Basics (seed)'; decks[name]={ name, createdAt:Date.now(), cards: rowsToCards(seed) }; saveAll(decks); }
    }
    setLife(getLife()); setSession(0);
    setLifeVocab(getLifeVocab());     // paint from storage
    setSessionVocab(0);               // new session starts at 0
    loadAllCards();
    buildQueue(); showFlash(); summarizeStats();
  })();
  </script>
</body>
</html>